package com.shazcom.gps.app.ui.activitiesimport android.os.Bundleimport android.view.Viewimport android.widget.CompoundButtonimport android.widget.Toastimport androidx.activity.viewModelsimport androidx.appcompat.app.AppCompatActivityimport androidx.core.view.isVisibleimport androidx.databinding.DataBindingUtilimport com.google.android.material.switchmaterial.SwitchMaterialimport com.shazcom.gps.app.Rimport com.shazcom.gps.app.data.LocalDBimport com.shazcom.gps.app.data.repository.ToolsRepositoryimport com.shazcom.gps.app.data.response.AlertDataimport com.shazcom.gps.app.data.response.Itemsimport com.shazcom.gps.app.databinding.ActivityAlertBindingimport com.shazcom.gps.app.network.GPSWoxAPIimport com.shazcom.gps.app.network.internal.Statusimport com.shazcom.gps.app.ui.dialogs.AlertSettingDialogimport com.shazcom.gps.app.ui.viewmodal.ToolsViewModelimport org.kodein.di.KodeinAwareimport org.kodein.di.android.closestKodeinimport org.kodein.di.generic.instanceclass AlertActivity : AppCompatActivity(), KodeinAware {    private lateinit var binding: ActivityAlertBinding    private val toolsViewModel: ToolsViewModel by viewModels()    override val kodein by closestKodein()    private val localDB: LocalDB by instance()    private val repository: ToolsRepository by instance()    private var deviceItem: Items? = null    private val alerts = mutableListOf<AlertData>()    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding = DataBindingUtil.setContentView(this, R.layout.activity_alert)        deviceItem = intent.getParcelableExtra("item")        toolsViewModel.toolsRepository = repository        initViews()        fetchAlerts()    }    private fun fetchAlerts() {        toolsViewModel.toolsRepository.loadAlerts("en", localDB.getToken()!!)            .observe(this) { state ->                binding.progressBar.isVisible = state.isLoading()                state.getErrorIfExist()?.let {                    Toast.makeText(this, it, Toast.LENGTH_SHORT).show()                    onBackPressed()                }                binding.uiGroup.isVisible = state.getDataOrNull() != null                state.getDataOrNull()?.let {                    val items: List<AlertData> =                        it.items.alerts.filter { it.devices.any { it == deviceItem?.id } }                    alerts.clear()                    alerts.addAll(items)                    updateUi()                }            }    }    private fun deleteAlertItem(id: Int, switchMaterial : SwitchMaterial) {        toolsViewModel?.destroyAlert("en", localDB?.getToken()!!, id)            ?.observe(this) { state ->                binding.progressBar.isVisible = state.isLoading()                state.getErrorIfExist()?.let {                    Toast.makeText(this, it, Toast.LENGTH_SHORT).show()                    onBackPressed()                }                state.getDataOrNull()?.let {                    binding.progressBar.isVisible = state.isLoading()                    switchMaterial.isChecked = false                    Toast.makeText(this, "Alert Sync successfully", Toast.LENGTH_SHORT).show()                }            }    }    private fun updateAlert(id: Int, switchMaterial : SwitchMaterial, type: String, name : String, state: Int) {        var finalUrl = ""        var baseUrl = "edit_alert"        finalUrl = "${GPSWoxAPI.BASE_URL}$baseUrl?lang=en&user_api_hash=${localDB.getToken()}&name=${name}&type=${type}&state=${state}&id=${id}&devices[]=${deviceItem?.id}&command[active]=${'0'}"        toolsViewModel?.editAlert(finalUrl)            ?.observe(this) { state ->                binding.progressBar.isVisible = state.isLoading()                state.getErrorIfExist()?.let {                    Toast.makeText(this, it, Toast.LENGTH_SHORT).show()                    onBackPressed()                }                state.getDataOrNull()?.let {                    binding.progressBar.isVisible = state.isLoading()                    switchMaterial.isChecked = false                    Toast.makeText(this, "Alert Sync successfully", Toast.LENGTH_SHORT).show()                }            }    }    private fun updateUi() {        alerts.lastOrNull { alertData -> alertData.type == "overspeed" }?.let { alert ->            binding.switchOverSpeed.isChecked = alert.active == 1            binding.switchOverSpeed.tag = alert.id            binding.subTitle.text = "Overspeed speed alarm (${alert.overspeed?:100}km/h)"        }        alerts.lastOrNull { alertData -> alertData.type == "idle_duration" }?.let { alert ->            binding.switchIdleDuration.isChecked = alert.active == 1            binding.switchIdleDuration.tag = alert.id            binding.subTitle.text = "Idle Duration alarm (${alert.idle_duration?:60}km/h)"        }        alerts.lastOrNull { alertData -> alertData.type == "ignition" }?.let { alert ->            binding.switchIgnitionOn.isChecked = alert.active == 1            binding.switchIgnitionOn.tag = alert.id            binding.switchIgnitionOff.isChecked = alert.active == 0        }        alerts.lastOrNull { alertData -> alertData.type == "geofence_in" }?.let { alert ->            binding.switchGeofenceIn.isChecked = alert.active == 1        }        alerts.lastOrNull { alertData -> alertData.type == "geofence_out" }?.let { alert ->            binding.switchGeofenceOut.isChecked = alert.active == 1        }    }    private fun initViews() {        binding.toolBar.setNavigationOnClickListener { onBackPressed() }        binding.toolBar.subtitle = deviceItem?.name        binding.switchOverSpeed.setOnClickListener {            if (binding.switchOverSpeed.isChecked.not()) {/*setAlert(                    binding.switchOverSpeed,                    binding.switchOverSpeed.isChecked.not(),                    "overspeed",                    status = 0,                    overSpeed = "0"                )*/                // call delete alert api                deleteAlertItem(binding.switchOverSpeed.tag as Int , binding.switchOverSpeed)            } else {                AlertSettingDialog(true)                    .setListener(                        onClickOk = { value ->                            setAlert(                                binding.switchOverSpeed,                                binding.switchOverSpeed.isChecked.not(),                                "overspeed",                                status = 1,                                overSpeed = value                            )                        },                        onClickCancel = {},                    )                    .show(supportFragmentManager, "")            }        }        binding.switchIdleDuration.setOnClickListener {            if (binding.switchIdleDuration.isChecked.not()) {                /*setAlert(                    binding.switchIdleDuration,                    binding.switchIdleDuration.isChecked.not(),                    "idle_duration",                    status = 0                )*/                deleteAlertItem(binding.switchIdleDuration.tag as Int,  binding.switchIdleDuration)            } else {                AlertSettingDialog()                    .setListener(                        onClickOk = { value ->                            setAlert(                                binding.switchIdleDuration,                                binding.switchIdleDuration.isChecked.not(),                                "idle_duration",                                status = 1,                                idleDuration = value                            )                        },                        onClickCancel = {},                    )                    .show(supportFragmentManager, "")            }        }        binding.switchGeofenceIn.setOnClickListener {            setAlert(binding.switchGeofenceIn, binding.switchGeofenceIn.isChecked.not(), "geofence_in")        }        binding.switchGeofenceOut.setOnClickListener {            setAlert(binding.switchGeofenceOut, binding.switchGeofenceOut.isChecked.not(), "geofence_out")        }        binding.switchIgnitionOn.setOnClickListener {            alerts.lastOrNull { alertData -> alertData.type == "ignition" }?.let { alert ->               print("ignition Alert $alert")            }            if (binding.switchIgnitionOn.isChecked.not()) {                // edit ignition on / off                updateAlert(binding.switchIgnitionOn.tag as Int, binding.switchIgnitionOn, "ignition", "ignition", 2)            }else {              setAlert(                binding.switchIgnitionOn,                binding.switchIgnitionOn.isChecked.not(),                "ignition",                status = 1            )            }        }        binding.switchIgnitionOff.setOnClickListener {            setAlert(                binding.switchIgnitionOff,                binding.switchIgnitionOff.isChecked.not(),                "ignition",                status = 0            )        }    }    private fun setAlert(        view: CompoundButton,        isChecked: Boolean,        type: String,        status: Int? = null,        overSpeed: String? = null,        idleDuration: String? = null,    ) {        var url = ""        url = if(type != "ignition") {            "${GPSWoxAPI.BASE_URL}add_alert?lang=en&user_api_hash=${localDB.getToken()}&type=$type&name=$type&devices[]=${deviceItem?.id}"        }else {            "${GPSWoxAPI.BASE_URL}add_alert?lang=en&user_api_hash=${localDB.getToken()}&type=$type&name=$type&devices[]=${deviceItem?.id}&command[active]=${'1'}"        }        if (status != null) {            url = "$url&state=$status"        }        if (overSpeed != null) {            url = "$url&overspeed=$overSpeed"        }        if (idleDuration.isNullOrEmpty().not()) {            url = "$url&idle_duration=${idleDuration?.toInt()}"        }        if (type.contains("geofence")) {            url = "$url&geofences[]=${365}"        }        toolsViewModel.addAlert(url).observe(this) { state ->            binding.progressBar.isVisible = state.isLoading()            binding.switchOverSpeed.isClickable = state.isLoading().not()            binding.switchGeofenceIn.isClickable = state.isLoading().not()            binding.switchGeofenceOut.isClickable = state.isLoading().not()            binding.switchIdleDuration.isClickable = state.isLoading().not()            binding.switchIgnitionOff.isClickable = state.isLoading().not()            binding.switchIgnitionOn.isClickable = state.isLoading().not()            state.getErrorIfExist()?.let { error ->                Toast.makeText(this, error, Toast.LENGTH_SHORT).show()            }            state.getDataOrNull()?.let {                Toast.makeText(this, "Success", Toast.LENGTH_SHORT).show()                fetchAlerts()            }        }    }}